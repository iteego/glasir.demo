/*
 * Copyright (C) 2011 Iteego Inc and Matias Bjarland <mbjarland@gmail.com>
 *
 * This file is part of Glasir, a Gradle build framework for ATG E-Commerce
 * projects created by Iteego Inc and Matias Bjarland.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

version = "1.0-SNAPSHOT"
group = "com.iteego.glasir"

/********************************************/
/* Some properties used in the build files  */

ext { 
  storeServerName = "dev-store"
  adminServerName = "dev-admin"
  
  databaseDir     = file("$jBossRoot/ATG-Data/h2.db")
  
  bigEarName      = "${rootProject.name}.ear"
  bigEar          = file("$buildDir/$bigEarName")
  docRoot         = "$rootDir/glasir-app/Main/j2ee-apps/GlasirApplication/glasir.war/"
  isReleaseBuild  = false
}
/********************************************/
/* Now apply some plugins and include files */

apply plugin: 'idea'
apply plugin: 'glasir.build'

apply from: "config/gradle/include/sub-projects.gradle"
apply from: "config/gradle/include/assembly-tasks.gradle"
apply from: "config/gradle/include/artifactory.gradle"
apply from: "config/gradle/include/jboss-tasks.gradle"
apply from: "config/gradle/include/rules.gradle"
apply from: "config/gradle/include/oracle-to-h2.gradle"

//apply from: "config/gradle/include/help.gradle"

//if we are running in the ci server, include some ci tasks
if (System.env['BUILD_NUMBER']) {
  apply from: 'config/gradle/include/ci.gradle'
}

/*********************************************
 * A gradle custom task for generating gradle 
 * install scripts so that the user of the 
 * repo does not need to install gradle           
*/

task none << {
  print "Accept license [y/n]: "
  def result = new Scanner(System.in).useDelimiter(System.properties['line.separator']).next()
  
  println ""
  println "Result: $result"
}

task prompt << {
  def p = "echo 'Accept license [y/n]: '".execute()
  p.print "Accept license [y/n]: "
  p.waitFor()
  def result = new Scanner(System.in).useDelimiter(System.properties['line.separator']).next()
  
  println ""
  println "Result: $result"
}


/*****************************************************************************
 * A gradle custom task for generating gradle install scripts so that the user
 * of the repo does not need to install gradle
*/
task wrapper(type: Wrapper) {
  gradleVersion = '1.3'
  jarFile = 'config/gradle/wrapper/gradle-wrapper.jar'
}

class ImportAndModule {
  /**
   * The XML node.
   */
  groovy.util.Node node

  /**
   * The module in where the dbinit.xml file is (the file that defines the imports). We need this to resolve paths.
   */
  com.iteego.glasir.build.api.AtgModule definingModule
}

task createGlasirDbData << {

  String mainModuleName = 'env.Main.store.dev.oracle'
  mainModuleName = 'env.Main.admin.dev.oracle'

  def fullModuleList = glasir.moduleMap[mainModuleName].fullBuildOrder

  Map<String, Node> namedDatasourceMap = new HashMap<String,Node>()
  Map<String, Object> instanceTypeMap = new HashMap<String, Object>()

  // Map datasource name to sql files.
  Map<String, List<String>> sqlFiles = new HashMap<String, List<String>>()

  // It is not certain that we want to group imports by datasource, maybe it should just be a list.
  Map<String, List<ImportAndModule>> importNodes = new HashMap<String, List<ImportAndModule>>()



  println "Install Units: ${glasir.installUnits}"
  println "Top level module list: " + glasir.modules.collect({it.name}).join(",") + "\n"

  // Read product.xml files for products.
  fullModuleList.findAll {
    file("${it.dir}/cim/product.xml").exists()
  }.each { module ->
    def productxml = new File("${module.dir}/cim/product.xml")
    println "Scanning file $productxml"
    def parser = new groovy.util.XmlParser(false, false)
    // Set these two features to skip dtd verification.
    parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
    parser.setFeature("http://xml.org/sax/features/namespaces", false)
    def root = parser.parse(productxml) // root should be the "database-initializer" node.

    if (root?.name() != "product" ) {
      println "Root element not recognized. Expected \"product\" Found \"${root.name()}\""
    } else {
      def productId = root.@id
      def requiredAddonsForThisProduct = root.'requires-addon-id'
      def requiredProductsForThisProduct = root.'product-id-required'
      def addons = root.'product-addon-group'

      println "Product \"$productId\" "
      if( requiredProductsForThisProduct ) println " required products: " + requiredProductsForThisProduct.collect{it.@id}.join(", ")
      if( requiredAddonsForThisProduct ) println " required addons  : " + requiredAddonsForThisProduct.collect{it.@id}.join(", ")

      def serverInstanceTypes = root.'server-instance-type'
      if( serverInstanceTypes ) println " instance types   : " + serverInstanceTypes.collect{it.@id}.join(", ")
      serverInstanceTypes.each { serverInstanceType ->
        def sitId = serverInstanceType.@id
        //println "  Server instance type \"$sitId\""
        instanceTypeMap[sitId] = serverInstanceType
      }

      root.'named-datasource'.each { nds ->
        namedDatasourceMap[ nds.@id ] = nds
      }
    }
  }

  println "__________________________________________"
  println "__________________________________________"

  // We will be using these server instance types below.
  def myInstanceTypes = [
    "management"
    //"production"
  ]

  // Addons are important in the selection of data imports and repository loader actions.
  def mySelectedAddons = [
      "dcs-csr",
      "international",
      "merch",
      "previewOnManagement",
      "prodLock",
      "queryConsoleOnManagement",
      "storefront-full-setup",
      //"storefront_no_publishing",
      "switchingdatasource"
    ]
  // These are the addons: find /home/mwangel/jobb/iteego/glasir.demo/packages -print0|grep -zZ -i product\.xml|xargs -0 grep '<product\-addon id\='
  //id="clicktoconnect"
  //id="cybersource"
  //id="dcs-csr"
  //id="externalPreviewServer"
  //id="fulfillment"
  //id="fulfillment_using_atg"
  //id="indexByProduct"
  //id="indexBySku"
  //id="international"
  //id="lock"
  //id="merch"
  //id="nonswitchingdatasource"
  //id="preview"
  //id="previewOnManagement"
  //id="prodLock"
  //id="pubLock"
  //id="queryConsoleOnManagement"
  //id="queryConsoleOnProduction"
  //id="reporting"
  //id="search"
  //id="staging"
  //id="storefront-basic-setup"
  //id="storefront-full-setup"
  //id="storefront_demo"
  //id="storefront_no_publishing"
  //id="switchingdatasource"

  /**
   * This is where we put the resulting files that glasir.db will later consume.
   */
  File outputMainDirectory = new File( "./importRootDir-$mainModuleName-${myInstanceTypes.join("_")}")

  /**
   * Where .sql files go after they have been transformed into XML.
   */
  File outputDbDirectory = new File( outputMainDirectory, "db" )

  /**
   * Where .sdl and .properties and .xml files go for data-import and repository-loader.
   */
  File outputImportDirectory = new File( outputMainDirectory, "import" )


  println "Selected addons: ${mySelectedAddons.join(", ")}"
  println "Selected instance types: ${myInstanceTypes.join(", ")}"

  // Read dbinit.xml files for the modules.
  //glasir.modules.each { module ->
  fullModuleList.each { module ->
    File cimDir = new File(module.dir as File, "cim")
    if (cimDir.exists()) {
      println "--------------------------"
      File dbinit = new File(cimDir, "dbinit.xml")
      if (dbinit.exists()) {
        println "Module      : ${module}"
        println "Install Unit: ${module.installUnit}"
        println "dbinit.xml  : $dbinit"


        def root = null
        try {
          // Using the constructor arguments "validating" and "namespaceAware" should work. Doesn't.
          def parser = new groovy.util.XmlParser(false, false)
          // Set these two features to skip dtd verification.
          parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
          parser.setFeature("http://xml.org/sax/features/namespaces", false)
          root = parser.parse(dbinit) // root should be the "database-initializer" node.


          if (root == null) {
            println "Root element not recognized. Expected \"database-initializer\" Found \"$root\""
          } else {
            // This tag name is used in both dbinit.dtd and product.dtd but they are different tags.
            def serverInstanceTypes = root.'server-instance-type'
            serverInstanceTypes.each { serverInstanceType ->
              if (myInstanceTypes.contains(serverInstanceType.@id)) {
                //println "Looking at server instance type \"${serverInstanceType.@id}\""

                def dataSources = serverInstanceType.datasource
                dataSources.each { datasource ->
                  String datasourceId = datasource.@id
                  //println "  For data source $datasourceId"

                  def requiredSchemas = datasource.schema
                  requiredSchemas.each { requiredSchema ->
                    def requiredSchemaId = requiredSchema.@id
                    //println "    Use schema ${requiredSchemaId}"

                    def schema = root.schema.find { it.@id == requiredSchemaId }
                    if (schema) {
                      schema.children().each { child ->
                        if (child.name() == "sql") {
                          //<!ELEMENT sql (path+)>
                          //<!ELEMENT path (requires-addon-id*,create,drop)>
                          child.path.each { sqlPath ->
                            if(sqlPath.create.text().contains("logical_org_ddl.sql")) {
                              println "$child"
                            }

                            def missing = false
                            if( sqlPath.'requires-addon-id' ) {
                              //println "      Create SQL: ${sqlPath.create.text()}"
                              //println "      Drop SQL  : ${sqlPath.drop.text()}"
                              println "        ---==> Sql path '${sqlPath.create.text()}' requires addons '${sqlPath.'requires-addon-id'.collect {it.@id}}'"
                              missing = sqlPath.'requires-addon-id'.any { !mySelectedAddons.contains(it.@id) }
                            }//if repository loader requires specific addons

                            if (!missing) {
                              if( !sqlFiles.containsKey(datasourceId) ) {
                                sqlFiles[datasourceId] = new ArrayList<String>()
                              }
                              def combinedPath = new File( module.dir as File, sqlPath.create.text() as String )
                              sqlFiles[datasourceId].add( combinedPath.absolutePath )
                            }//if !missing
                          }
                        }
                        else if (child.name() == "data-import") {
                          // DTD: <!ELEMENT data-import (requires-addon-id*,incompatible-addon-id*,repository-path,import-file-path,user?,workspace?,comment?)>
                          def dataimport = child
                          def repoPath = dataimport.'repository-path'.text()
                          def filePath = dataimport.'import-file-path'.text() // Relative to the ATG root, presumably.
                          def startups = dataimport.@'start-up-module'

                          String s = "DataImport: Repository:$repoPath Path:$filePath Module:${startups} (defined in ${module.name})"
                          if (dataimport.'requires-addon-id') println "       ---==> Data Import $filePath requires addons '${dataimport.'requires-addon-id'.collect {it.@id}}'"
                          if (dataimport.'incompatible-addon-id') println "       ---==> Data Import $filePath is incompatible with addons '${dataimport.'incompatible-addon-id'.collect {it.@id}}'"
                          if (dataimport.user) println "       ---==> Data Import $filePath requires user '${dataimport.user.text()}'"
                          if (dataimport.workspace) println "       ---==> Data Import $filePath requires workspace '${dataimport.workspace.text()}'"

                          def missing = false
                          def blocked = false
                          if (dataimport.'requires-addon-id' || dataimport.'incompatible-addon-id') {
                            missing = dataimport.'requires-addon-id'.any { !mySelectedAddons.contains(it.@id) }
                            blocked = dataimport.'incompatible-addon-id'.any { mySelectedAddons.contains(it.@id) }
                          }

                          if(!missing && !blocked) {
                            if(!importNodes.containsKey( datasourceId ) ) {
                              importNodes[datasourceId] = new ArrayList<ImportAndModule>()
                            }
                            importNodes[datasourceId].add new ImportAndModule( node:dataimport, definingModule: module )
                          }
                        }
                        else if (child.name() == "repository-loader") {
                          // DTD: <!ELEMENT repository-loader (requires-addon-id*,cleanup-src-module?,cleanup-file-path?,files+,file-mapping,folder-mapping)>
                          // DTD: <!ELEMENT files (src-module,(config-path|file-path),file-pattern)>
                          def repoloader = child
                          def missing = false
                          if (repoloader.'requires-addon-id') {
                            println "        ---==> Repository loader requires addons '${repoloader.'requires-addon-id'.collect {it.@id}}'"
                            missing = repoloader.'requires-addon-id'.any { !mySelectedAddons.contains(it.@id) }
                          }//if repository loader requires specific addons
                          if( !missing ) {
                            if( !importNodes.containsKey(datasourceId) ) {
                              importNodes[ datasourceId ] = new ArrayList<ImportAndModule>()
                            }
                            importNodes[ datasourceId ].add new ImportAndModule( node:repoloader, definingModule: module )
                          }//if !missing
                        }
                        else {
                          println "ERROR! UNKNOWN SCHEMA CHILD NAME '${child.name()}'. EXPECTED sql, data-import or repository-loader."
                        }

                      } // schema.each
                    } else {
                      println "ERROR! MISSING SCHEMA '$requiredSchemaId' FOR DATASOURCE '${datasource.@id}' IN SERVER INSTANCE TYPE '${serverInstanceType.@id}' IN FILE '$dbinit'."
                    }
                  } // if data source has schemas
                }//for each data source
              } else {
                //println "Ignoring server instance type \"${serverInstanceType.@id}\""
              }
            }//for each server instance type

          }
        }
        catch (Throwable e) {
          println "Failed to read file: \"$dbinit\". Message: $e"
        }
      } else {
        println "(File not found: \"dbinit.xml\" for module \"${module.name}\")"
      }
    }//if directory cim exists
  }//for each module

  println ""
  println "Named JNDI data sources:\n ${namedDatasourceMap.collect{ "${it.key} -> ${it.value.jndi.text()}" }.join("\n ") }"
  println ""

  println "*******"
  println "* SQL *"
  println "*******"
  sqlFiles.keySet().each { key ->
    def jndi = namedDatasourceMap[key]?.jndi?.text()
    println "Datasource name: $key (JNDI \"$jndi\")"
    sqlFiles[key].each { statement ->
      println statement
    }
  }


  // Get data files from jar files or directories, copy them to specific places, create the imports.txt file.
  List<String> importCommands = new ArrayList<String>()
  importNodes.keySet().each { key ->
    println "\nDatasource name: $key"

    importNodes[key].each { entry ->
      if( entry.node.name() == "data-import" ) {
        String repoPath = entry.node.'repository-path'.text()
        String filePath = entry.node.'import-file-path'.text() // Relative to the ATG root, presumably.
        String startups = entry.node.@'start-up-module'
        startups = startups?.replaceAll( " ", "" )
        if( !startups ) {
          startups = entry.definingModule.name
          println "WARNING: data-import: start-up-module is empty, using defining module name: '$startups'. Import-file-path='$filePath'. Repository-path='$repoPath'."
        }

        File fromPath = new File( filePath )
        File baseDir = glasir.model.atgRootDir
        File fromFile = new File( baseDir, filePath )
        File toDir = new File( outputImportDirectory, fromPath.parent )
        File toFile = new File( outputImportDirectory, fromPath.toString() )
        if( !fromFile.exists() ) {
          println "ERROR: data-import: file not found: '$fromFile'"
        }
        //println "DEBUG: data-import: copy from '$fromFile' to '$toFile'."
        if( !toDir.exists() ) {
          def mkdirs = toDir.mkdirs()
          if( !mkdirs ) {
            println "ERROR: data-import: mkdirs() failed for path '$toDir'."
            throw new Exception("FAIL: mkdirs $toDir")
          }
        }
        if( toFile.exists() ) {
          def rmFile = toFile.delete()
          if( !rmFile ) {
            println "ERROR: data-import: delete failed for file '$toFile'."
          }
        }

        // Copy
        // Todo: Copy file in a way that can not cause out-of-memory exceptions in the JVM.
        toFile << fromFile.bytes

        // Add the command to the import list.
        String command = "DataImport: Repository:$repoPath Path:$filePath Module:${startups}"
        importCommands.add command

      } else if( entry.node.name() == "repository-loader" ) {

        def repoloader = entry.node
        List<String> files = new ArrayList<String>()
        repoloader.files.each { repoFile ->
          String srcModuleName = repoFile.'src-module'.text()
          def srcModule = glasir.module( srcModuleName )
          String filePattern = repoFile.'file-pattern'.text()
//          println "src-module : $srcModuleName"
//          println "resolved to: $srcModule"
//          println "with config path: ${srcModule.manifest.atgConfigPath}"

          // Create <outputDirectory>/import/$moduleName/
          File moduleToDir = new File( outputImportDirectory, srcModuleName )
          File fileToDir = null
          File fromFile = null

          if (repoFile.'config-path') {
            String configPath = repoFile.'config-path'.text()

            // Create <outputDirectory>/import/$moduleName/$configPath/
            //fileToDir = new File( moduleToDir, configPath )

            // Get the file (it can be in a jar file)
            File config = new File( srcModule.dir as File, srcModule.manifest.atgConfigPath as String )
            if( config.isFile() ) {
              if( config.name.toLowerCase().endsWith(".jar") ) {
                //println " copy from zipTree '$config', include '$configPath/$filePattern', into '$moduleToDir'"
                copy {
                  from zipTree( config )
                  include( "$configPath/$filePattern" )
                  into moduleToDir
                }
              } else {
                println "ERROR: THE CONFIG-PATH FOR MODULE $srcModuleName IS A FILE BUT NOT A JAR."
              }
            } else {
              println " copy from fileTree '$config', include '$configPath/$filePattern', into '$moduleToDir'"
              copy {
                from fileTree( config )
                include( "$configPath/$filePattern" )
                into moduleToDir
              }
            }

            //println "  ==> Repository loader with config-path $configPath. Module ${module.name}. File ${dbinit}. Schema ${requiredSchemaId}"
            def fs = "${System.properties['file.separator']}"
            files.add("$srcModuleName$fs$configPath$fs$filePattern")
          }
          else if (repoFile.'file-path') {
            def filePath = repoFile.'file-path'.text()
            println "  ==> Repository loader with file-path $filePath. Module ${module.name}. File ${dbinit}. Schema ${requiredSchemaId}"
            files.add("${repoFile.'file-path'.text()}${System.properties['file.separator']}${repoFile.'file-pattern'.text()}")
          }

        }

        // Add the repoloader definition in the glasir.db format
        String command = "RepoLoader:files=\"${files.join(" & ")}\" fileMapping=\"${repoloader.'file-mapping'.text()}\" folderMapping=\"${repoloader.'folder-mapping'.text()}\""
        importCommands.add command
      }

    }
  }

  File commandFile = new File( outputMainDirectory, "imports.txt" )
  commandFile.text = importCommands.join( System.properties["line.separator"] as String )
  println "---------------------------------------------------------------------"
  println "IMPORT FILE: $commandFile"
  println "---------------------------------------------------------------------"
}
