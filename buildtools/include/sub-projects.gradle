
import static org.apache.ivy.util.url.CredentialsStore.INSTANCE as ivy

/******************************************************************************
 * Gradle project and sub-project setup calls
 *****************************************************************************/

allprojects {
  apply plugin: 'groovy'
  
  repositories {
    //TODO: we might or might not want customers connecting to our repo
    ivy.addCredentials("Artifactory Realm", "iteego.artifactoryonline.com", artifactoryReader, artifactoryReaderPwd)    
    mavenRepo url: 'http://iteego.artifactoryonline.com/iteego/glasir-repos'
  }
  
  dependencies {  
    def groovyVersion = "org.codehaus.groovy:groovy:1.7.9"

    // The below enables us to write atg classes in mixed java/groovy. Groovy
    // jar will be downloaded and cached from a maven repo on demand.
    groovy groovyVersion

    testCompile "junit:junit:4.8.2", 
                "org.mockito:mockito-all:1.8.5",
		            groovyVersion

    //settings for geb/spock/selenium      
    def gebVersion = "0.6.1"
    def seleniumVersion = "2.9.0"
 
    //TODO: investigate if we can use spock 0.5-groovy-1.8 and move to groovy 1.8
    // If using Spock, need to depend on geb-spock
    testCompile "org.codehaus.geb:geb-spock:$gebVersion"
    testCompile "org.spockframework:spock-core:0.5-groovy-1.7"
 
    // If using JUnit, need to depend on geb-junit (3 or 4)
    testCompile "org.codehaus.geb:geb-junit4:$gebVersion"
    testCompile "junit:junit-dep:4.8.2"
 
    // The drivers we want to use
    drivers = ["htmlunit"] //, "firefox", "chrome"]

    // Need a driver implementation
    drivers.each { driver ->
      testCompile "org.seleniumhq.selenium:selenium-${driver}-driver:$seleniumVersion"
    }
    testRuntime "org.seleniumhq.selenium:selenium-support:$seleniumVersion"              
  }

  drivers.each { driver ->
    task "${driver}Test"(type: Test) {
      testReportDir = file("$reportsDir/$name/tests")
      testResultsDir = file("$buildDir/test-results/$name")
      
      isGebTask = true
  
      systemProperty "geb.build.reportsDir", "$reportsDir/$name/geb"
      systemProperty "geb.env", driver
  
      // If you wanted to set the baseUrl in your buildâ€¦
      // systemProperty "geb.build.baseUrl", "http://myapp.com"
    }
  }
  
  //exclude the geb tests from the normal unit test run. unit tests should be run post
  //compile but should not require a live node. We need to separate these two beasts.
  test {
    exclude '**/*GebSpec.class'
  }
  //task test(overwrite: true, dependsOn: drivers.collect { tasks["${it}Test"] })


  sourceCompatibility = "1.6"
  targetCompatibility = "1.6"
  
  compileJava {
    options.compilerArgs = ['-Xlint:deprecation'] //, '-Xlint:unchecked']
  }
}

subprojects {
  // set the maven 'group' for the sub project,
  group = getProjectGroup(project, true)

  setupAtgDependencies(project, ['compile', 'testCompile'])

  task print << {
    printTree(project)
  }

  jar  {
    //only create a jar file if we have some classes to jar up, 
    //to to this we check if the 'compileJava' task did any work (if so, we have something
    //to jar up). TODO: if we need to create resources-only jars, this needs changing
    onlyIf {
      compileJava.didWork || processResources.didWork || compileGroovy.didWork
    }

    // Change where the resulting jar will end up
    destinationDir = file("lib")
    baseName = 'classes'
  }
      
  clean << {
    ant.delete file: 'lib/classes.jar'
    if (!file('lib').listFiles()) {
      ant.delete dir: 'lib'
    }
  }
}


task aggregateTestReports(type: TestReportAggregator, dependsOn: test) {
    testReportDir = file("${reportsDir}/tests")
    testResultsDir = file("${buildDir}/test-results")
    projects = subprojects
}
build.dependsOn(aggregateTestReports)

gradle.projectsEvaluated { g ->
  build.dependsOn(getTasksByName('build', true) - build)
  clean.dependsOn(getTasksByName('clean', true) - clean)
}

class TestReportAggregator extends Copy {
    def projects
    File testResultsDir
    
    @OutputDirectory
    File testReportDir
    
    def TestReportAggregator() {
        dependsOn { testTasks }
        from { inputTestResultDirs }
        into { testResultsDir }
    }

    @TaskAction
    def aggregate() {
        def report = new org.gradle.api.internal.tasks.testing.junit.report.DefaultTestReport(testReportDir: testReportDir, testResultsDir: testResultsDir)
        report.generateReport()
    }

    def getTestTasks() {
        //TODO: Clean this dependency up...
        //Here we make sure that when we aggregate the normal unit tests, we don't pull in the 
        //geb tests. This would force geb tests to be executed when you run normal unit tests 
        //and break the build. 
        projects.collect { it.tasks.withType(Test) }
                .flatten()
                .findAll { !it.hasProperty('isGebTask') }

    }

    def getInputTestResultDirs() {
        testTasks*.testResultsDir
    }
}